#include "RISCVMIR.hpp"
#include "MagicEnum.hpp"

RISCVMOperand*& RISCVMIR:: GetDef() {return def;}
RISCVMOperand*& RISCVMIR::GetOperand(int ind){
    assert(0<=ind&&ind<operands.size()&&"Range Assertion");
    return operands[ind];
}

void RISCVMIR::SetDef(RISCVMOperand* def){
    this->def=def;
}
void RISCVMIR::AddOperand(RISCVMOperand* op){
    operands.push_back(op);
}
void RISCVMIR::SetMopcode(RISCVISA isa) {
    this->opcode=isa;
}

void RISCVMIR::printfull(){
    std::string name(magic_enum::enum_name(opcode));
    if (name.find('_') != std::string::npos) name.erase(0,1);
    size_t pos=0;
    while((pos=name.find('_'))!=std::string::npos) name.replace(pos, 1, ".");
    std::cout<<"\t"<< name <<" ";
    
    if(name=="ret") {std::cout<<"\n";}
    else if (name=="call") {
        operands[0]->print();
    }
    else {
        if(def!=nullptr) {
            def->print();
            if(operands.size()>0) std::cout << ", ";
        }
        for(int i=0;i<operands.size();i++){
            operands[i]->print();
            if(i!=operands.size()-1)
                std::cout<<", ";
        }
        std::cout<<"\n";
    }
}

std::vector<std::unique_ptr<RISCVFrameObject>>& RISCVFunction::GetFrameObjects(){
    return frame;
}

RISCVBasicBlock::RISCVBasicBlock(std::string _name):NamedMOperand(_name,RISCVType::riscv_none){}

RISCVBasicBlock* RISCVBasicBlock::CreateRISCVBasicBlock(){
    static int cnt=0;
    return new RISCVBasicBlock(".LBB"+std::to_string(cnt++));
}

void RISCVBasicBlock::replace_succ(RISCVBasicBlock* from,RISCVBasicBlock* to){
    for(auto it=rbegin();it!=rend();++it){
        RISCVMIR* inst=*it;
        RISCVMIR::RISCVISA opcode = inst->GetOpcode();
        if(opcode<RISCVMIR::EndBranch&&opcode>RISCVMIR::BeginBranch){
            bool flag=false;
            for(int i=0;i<inst->GetOperandSize();i++){
                if(inst->GetOperand(i)==from){
                    inst->SetDef(to);
                    flag=true;
                }
            }
            if(flag)return;
        }
    }
    assert(0&&"IMPOSSIBLE");
}

void RISCVBasicBlock::push_before_branch(RISCVMIR* minst) {
    assert(this->Size()!=0 && "Empty BasicBlock"); 
    for(auto it=this->rbegin(); it!=this->rend(); --it) {
        RISCVMIR* inst=*it;
        RISCVMIR::RISCVISA opcode = inst->GetOpcode();
        if(opcode<RISCVMIR::BeginBranch || opcode>RISCVMIR::EndBranch) {
            assert(!(opcode==RISCVMIR::ret)&&"ret"); 
            it.insert_after(minst);
            return;
        } 
    }
    this->push_front(minst);
}

RISCVFunction::RISCVFunction(Value* _func):RISCVGlobalObject(_func->GetType(),_func->GetName()),func(_func){}


void RISCVBasicBlock::printfull(){
    NamedMOperand::print();
    std::cout<<":\n";
    for(auto minst:*this)
        minst->printfull();
}

/// @todo the entry bb, or prologue bb will be generated by RISCVFunction after RA, and will be named as entry?
void RISCVFunction::printfull(){
    
    NamedMOperand::print();
    std::cout<<":\n";
    for(auto mbb:*this){
        mbb->printfull();
        // if(mbb!=this->back())
        //     std::cout<<"\n";
    }
}